(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{436:function(t,a,e){"use strict";e.r(a);var _=e(3),v=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"大模型训练"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大模型训练"}},[t._v("#")]),t._v(" 大模型训练")]),t._v(" "),a("ClientOnly",[a("title-pv")],1),t._v(" "),a("h2",{attrs:{id:"数据准备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据准备"}},[t._v("#")]),t._v(" 数据准备")]),t._v(" "),a("p",[t._v("数据通常分为通用数据，如网页、书籍、对话；以及专业数据，如多语言数据、科学文本（学术论文）、代码等等")]),t._v(" "),a("h2",{attrs:{id:"数据清洗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据清洗"}},[t._v("#")]),t._v(" 数据清洗")]),t._v(" "),a("p",[t._v("为保证大模型使用高质量语料训练，通常需要质量过滤，包括冗余去除、隐私消除、词元切分等步骤")]),t._v(" "),a("h2",{attrs:{id:"数据选取、划分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据选取、划分"}},[t._v("#")]),t._v(" 数据选取、划分")]),t._v(" "),a("h3",{attrs:{id:"scaling-law"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scaling-law"}},[t._v("#")]),t._v(" Scaling Law")]),t._v(" "),a("p",[t._v("对于计算量"),a("smalltex",[t._v("C")]),t._v("，模型参数量"),a("smalltex",[t._v("N")]),t._v("，和数据集大小"),a("smalltex",[t._v("D")]),t._v("，当不受其他两个因素制约时，模型性能"),a("smalltex",[t._v("L")]),t._v("与每个因素都呈现幂律关系，且随着每个因素的量增大，对模型的效果提升越有限。目前已经有研究证明，模型参数量上升时，数据量也需要等比例上升。")],1),t._v(" "),a("h3",{attrs:{id:"数据选取方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据选取方法"}},[t._v("#")]),t._v(" 数据选取方法")]),t._v(" "),a("ul",[a("li",[t._v("Data Mixing Laws：通过在小规模数据和模型上进行实验，利用训练步数、模型大小和数据混合比例的缩放定律（Scaling Laws），来预测在大规模数据和大型模型上的性能")]),t._v(" "),a("li",[t._v("DoGE/LESS：重点学习对整体梯度贡献较大的领域，可以使用影响函数来量化每条训练数据对模型的影响。但通常在大模型上直接计算影响函数是困难的，因此可以先知识蒸馏，在小模型上用影响函数分析什么样的数据是关键的")]),t._v(" "),a("li",[t._v("REGMIX：使用多种数据配比训练一组小型模型，并拟合一个回归模型来预测给定各自配比的模型的性能")])]),t._v(" "),a("h2",{attrs:{id:"训练过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#训练过程"}},[t._v("#")]),t._v(" 训练过程")]),t._v(" "),a("h3",{attrs:{id:"pre-train"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pre-train"}},[t._v("#")]),t._v(" Pre-train")]),t._v(" "),a("p",[t._v("预训练阶段是通过大规模无监督学习来训练模型，让模型能够从海量的文本数据中学习语言的基本模式、语义和结构。通过学习大量文本，模型掌握语言的句法、词法，甚至潜在的语义关联。通常，预训练需要大量的数据和计算资源来处理巨大的参数量。模型在没有标注数据的情况下学习，需要高质量的数据清洗和设计合适的任务来让模型能够充分理解语言。")]),t._v(" "),a("h3",{attrs:{id:"sft-supervised-fine-tuning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sft-supervised-fine-tuning"}},[t._v("#")]),t._v(" SFT (Supervised Fine-Tuning)")]),t._v(" "),a("p",[t._v("在这个阶段，预训练好的模型会通过特定的任务和标注数据进行微调。这个步骤的目的是让模型在预训练的基础上，针对具体应用场景（如分类、问答、翻译等）进行适应性优化。")]),t._v(" "),a("p",[t._v("相比完全从头训练一个新模型，微调在时间和计算资源上更加经济高效。但有可能出现过拟合以及灾难性遗忘，即微调后的模型可能在特定领域表现良好，但在其他领域的表现可能会下降。")]),t._v(" "),a("h3",{attrs:{id:"rlhf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rlhf"}},[t._v("#")]),t._v(" RLHF")]),t._v(" "),a("div",{staticStyle:{"text-align":"center"}},[a("img",{staticStyle:{"margin-bottom":"-20px"},attrs:{src:"/img/dpoppo.png",width:"100%",height:"100%"}})]),t._v(" "),a("p",[t._v("在LLM对齐问题上，OpenAI提出的RLHF训练范式最为人熟知，同时也是ChatGPT行之有效的对齐方案。")]),t._v(" "),a("p",[t._v("RLHF通常包含三个步骤：SFT, Reward Model, PPO, 该方案优点不需多说，缺点也很明显：训练流程繁琐、算法复杂、超参数多和计算量大，因此RLHF替代方案层出不穷。")]),t._v(" "),a("h4",{attrs:{id:"ppo-proximal-policy-optimization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ppo-proximal-policy-optimization"}},[t._v("#")]),t._v(" PPO (Proximal Policy Optimization)")]),t._v(" "),a("p",[t._v("PPO 是一种在线强化学习方法，的核心是训练一个能更好刻画人类偏好的 Reward Model，然后使用这个 Reward Model 来显性评估模型生成结果的好坏，最终指导模型的微调。")]),t._v(" "),a("p",[t._v("PPO 主要缺点是需要训练单独的 Reward Model，其成本高昂并且需要大量额外数据。而 Reward Model 的好坏也直接影响了最终模型的效果。模型也有可能仅仅去学习如何讨好强化学习模型，而没有真正理解答案间的语义差距。")]),t._v(" "),a("h4",{attrs:{id:"dpo-direct-preference-optimization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dpo-direct-preference-optimization"}},[t._v("#")]),t._v(" DPO (Direct Preference Optimization)")]),t._v(" "),a("p",[t._v("DPO 是一种离线强化学习方法，无需显性构建 Reward Model，而是直接根据偏好数据来优化策略。它巧妙地绕过了构建奖励模型和强化学习这两个的繁琐过程，直接通过偏好数据进行微调，效果简单粗暴，在使模型输出更符合人类偏好的同时，极大地缩短了训练时间和难度。")]),t._v(" "),a("p",[t._v("然而，四川大学的 Duanyu Feng 最近的研究《Towards Analyzing and Understanding the Limitations of DPO: A Theoretical Perspective》表明：DPO 损失函数降低产生人类不喜欢的 response 的概率的速度比增加产生人类偏好的 response 的概率的速度更快，这导致：")]),t._v(" "),a("ul",[a("li",[t._v("DPO 阻碍了 LLM 产生人类偏好的 response 的学习能力")]),t._v(" "),a("li",[t._v("DPO 对 SFT 的有效性很敏感")])]),t._v(" "),a("h4",{attrs:{id:"两者的优势与不足"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两者的优势与不足"}},[t._v("#")]),t._v(" 两者的优势与不足")]),t._v(" "),a("p",[t._v("PPO 和 DPO 作为 LLMs Alignment 的主流算法有其各自的优势。PPO 训练一个单独的 Reward Model 来预测人类偏好。然后使用这个 Reward Model 来微调 LLMs。DPO 使用 KL constraint 直接导出最优策略，无需单独的 Reward Model。简化了 LLMs 训练流程，计算效率更高。DPO 在计算、速度和工程工作方面更加高效，但在模型效果上 PPO 要优于 DPO。在实际应用中可以根据具体需求进行选择。")]),t._v(" "),a("h2",{attrs:{id:"微调技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微调技术"}},[t._v("#")]),t._v(" 微调技术")]),t._v(" "),a("h3",{attrs:{id:"adapter-tuning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adapter-tuning"}},[t._v("#")]),t._v(" Adapter tuning")]),t._v(" "),a("p",[t._v("Adapter tuning通过在预训练模型的每一层中插入一个小的适配器模块来实现微调。这些适配器模块包含少量可训练参数，它们在微调过程中被更新，而原始模型的参数保持不变。适配器通常由两个线性层组成，中间可能有一个非线性激活函数。")]),t._v(" "),a("p",[t._v("假设原始模型的第"),a("smalltex",[t._v("l")]),t._v("层的输出为"),a("smalltex",[t._v("H_l")]),t._v("，则经过适配器后的输出"),a("smalltex",[t._v("H'"),a("em",[t._v("l")])]),t._v("可以表示为："),a("smalltex",[t._v("H'"),a("em",[t._v("l = F(H_lW")]),t._v("{down} + b"),t._v("{down})W_{up} + b_{up}")]),t._v("\n其中，"),a("smalltex",[t._v("F")]),t._v("是非线性激活函数，"),a("smalltex",[t._v("W_{down}和b_{down}")]),t._v("是降维层的权重和偏置，"),a("smalltex",[t._v("W_{up}")]),t._v("和"),a("smalltex",[t._v("b_{up}")]),t._v("是升维层的权重和偏置。")],1),t._v(" "),a("p",[t._v("假设我们有一个预训练的BERT模型，我们想要对其进行适配器微调以适应一个新的文本分类任务。我们会在BERT的每一层后添加适配器模块，并只训练这些模块的参数，而不改变BERT的原始参数。")]),t._v(" "),a("h3",{attrs:{id:"prompt-tuning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prompt-tuning"}},[t._v("#")]),t._v(" Prompt tuning")]),t._v(" "),a("p",[t._v("Prompt tuning是一种利用自然语言提示(prompt)来引导预训练语言模型的方法。这种方法不需要修改模型的内部参数，而是通过设计合适的提示来激发模型对特定任务的理解和执行。")]),t._v(" "),a("p",[t._v("假设我们要使用GPT-3进行问答任务，我们可以设计一个提示：“请回答以下问题：”，然后将这个问题作为输入的一部分，连同原始问题一起输入到GPT-3中。")]),t._v(" "),a("h3",{attrs:{id:"prefix-tuning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prefix-tuning"}},[t._v("#")]),t._v(" Prefix tuning")]),t._v(" "),a("p",[t._v("Prefix tuning是Prompt tuning的一种变体，它在输入序列的前面添加一组可学习的虚拟token作为前缀。这些虚拟token在训练过程中被优化，以更好地引导模型的输出。")]),t._v(" "),a("p",[t._v("假设我们要对一个生成模型进行微调，以便它能够生成特定风格的文本。我们可以添加一个可学习的前缀，这个前缀在训练过程中被优化，以使模型生成符合特定风格的文本。")]),t._v(" "),a("h3",{attrs:{id:"p-tuning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#p-tuning"}},[t._v("#")]),t._v(" P-tuning")]),t._v(" "),a("p",[t._v("P-tuning是一种将Prompt转换为可学习的Embedding的方法。它使用一个小型的神经网络来生成Prompt的Embedding，然后将这些Embedding与输入数据一起送入预训练模型。")]),t._v(" "),a("p",[t._v("假设我们要使用BERT进行情感分析任务，我们可以设计一个提示，并通过一个小的神经网络将其转换为Embedding，然后将这个Embedding与文本输入一起送入BERT。")]),t._v(" "),a("h3",{attrs:{id:"freeze-tuning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#freeze-tuning"}},[t._v("#")]),t._v(" Freeze tuning")]),t._v(" "),a("p",[t._v("Freeze tuning是指在微调过程中冻结模型的大部分参数，只训练模型的一小部分参数，通常是最后一层或者特定的几层。")]),t._v(" "),a("h3",{attrs:{id:"lora"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lora"}},[t._v("#")]),t._v(" LoRA")]),t._v(" "),a("p",[t._v("LoRA（Low-Rank Adaptation）是一种通过低秩矩阵分解来微调模型的方法。它通过添加一对低秩矩阵来近似参数更新，从而减少需要训练的参数数量。")]),t._v(" "),a("p",[t._v("假设原始参数矩阵为"),a("smalltex",[t._v("W")]),t._v("，LoRA通过添加低秩矩阵"),a("smalltex",[t._v("B")]),t._v("和"),a("smalltex",[t._v("A")]),t._v("来近似参数更新："),a("smalltex",[t._v("W_{new} = W + BA")]),t._v("，其中，"),a("smalltex",[t._v("B")]),t._v("和"),a("smalltex",[t._v("A")]),t._v("是低秩矩阵，它们的乘积近似于参数更新"),a("smalltex",[t._v("\\Delta W")]),t._v("。")],1),t._v(" "),a("p",[t._v("LoRA通常在Self-attention层调整参数，并且可以应用各种低精度技术。")]),t._v(" "),a("h3",{attrs:{id:"qlora"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qlora"}},[t._v("#")]),t._v(" QLoRA")]),t._v(" "),a("p",[t._v("QLoRA（Quantized LoRA）是LoRA的一个变体，它结合了量化技术来进一步减少模型的大小和提高微调效率。QLoRA在微调过程中使用量化技术来减少模型参数的位数，从而减少内存占用和计算需求。")]),t._v(" "),a("p",[t._v("QLoRA的公式与LoRA相似，但是在参数更新时会应用量化操作："),a("smalltex",[t._v("W_{new} = Q(W + BA)")]),t._v("，其中，"),a("smalltex",[t._v("Q")]),t._v("表示量化操作。")],1),t._v(" "),a("h2",{attrs:{id:"tokenizer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tokenizer"}},[t._v("#")]),t._v(" Tokenizer")]),t._v(" "),a("h3",{attrs:{id:"byte-pair-encoding-bpe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byte-pair-encoding-bpe"}},[t._v("#")]),t._v(" Byte-Pair Encoding(BPE)")]),t._v(" "),a("p",[t._v("BPE是一种无监督的分词技术，它从字符级别开始，逐步合并最常见的字符对，以形成更大的词汇单元。这个过程是迭代的，每次迭代都会根据新的词汇表重新计算字符对的频率，并合并最频繁出现的字符对。")]),t._v(" "),a("p",[t._v('假设有一个简单的语料库："I like apples, I like oranges."，初始词汇表只包含单个字符。BPE的步骤如下：')]),t._v(" "),a("ol",[a("li",[t._v("初始化词汇表：{'I', ' ', 'l', 'i', 'k', 'e', 'a', 'p', 'p', 'l', 'e', 's', ',', 'o', 'r', 'a', 'n', 'g', '.'}")]),t._v(" "),a("li",[t._v("统计字符对频率：'I like' 出现两次，'like ' 出现两次，等等。")]),t._v(" "),a("li",[t._v("合并最频繁的字符对：'like' 和 ' '（空格）合并为 'like_'。")]),t._v(" "),a("li",[t._v("更新词汇表：{'I', 'like_', 'apples,', 'oranges.'}")]),t._v(" "),a("li",[t._v("重复步骤2-4，直到达到所需的词汇表大小或满足其他停止条件。")])]),t._v(" "),a("p",[t._v("最终，词汇表可能包含像 'like_', 'apples,', 'oranges.' 这样的词汇单元，以及原始的字符。")]),t._v(" "),a("h3",{attrs:{id:"wordpiece"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wordpiece"}},[t._v("#")]),t._v(" WordPiece")]),t._v(" "),a("p",[t._v("WordPiece是一种基于BPE的分词方法，它通过合并字符或子词来优化语言模型的困惑度。WordPiece的目标是创建一个能够最大化句子概率的词汇表。")]),t._v(" "),a("p",[t._v("继续使用上面的例子，WordPiece可能会合并 'like' 和 ' '（空格）为 'like_'，然后继续寻找其他可以合并的子词，以提高整个语料库的概率。")]),t._v(" "),a("h3",{attrs:{id:"sentencepiece"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sentencepiece"}},[t._v("#")]),t._v(" SentencePiece")]),t._v(" "),a("p",[t._v("SentencePiece是一个开源工具，它提供了多种分词方法，包括BPE和Unigram。SentencePiece的特点是可以处理任何语言，包括那些没有空格分隔的语言，如中文。")]),t._v(" "),a("h3",{attrs:{id:"unigram"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unigram"}},[t._v("#")]),t._v(" Unigram")]),t._v(" "),a("p",[t._v("Unigram是一种基于概率的分词方法，它通过最大化整个语料库的似然概率来构建词汇表。Unigram模型在每次迭代中尝试合并词汇表中的项，并选择能够提高语料库概率的合并")]),t._v(" "),a("h3",{attrs:{id:"bpe的优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bpe的优势"}},[t._v("#")]),t._v(" BPE的优势")]),t._v(" "),a("ul",[a("li",[t._v("更好的处理未知词汇")]),t._v(" "),a("li",[t._v("更小的词汇表")]),t._v(" "),a("li",[t._v("更好的捕捉词缀和词形变化")]),t._v(" "),a("li",[t._v("跨语言的通用性")])]),t._v(" "),a("h2",{attrs:{id:"训练损失函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#训练损失函数"}},[t._v("#")]),t._v(" 训练损失函数")]),t._v(" "),a("h3",{attrs:{id:"bert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bert"}},[t._v("#")]),t._v(" BERT")]),t._v(" "),a("ul",[a("li",[t._v("MLM (Masked Language Model)：在MLM任务中掩盖部分词汇，并通过最大化掩盖词汇的预测概率来进行训练，假设"),a("smalltex",[t._v("T")]),t._v("是被掩盖的词语集合，"),a("smalltex",[t._v("p_\\theta(w_t|C)")]),t._v("是模型在上下文"),a("smalltex",[t._v("C")]),t._v("下预测词汇"),a("smalltex",[t._v("w_t")]),t._v("的概率，那么MLM损失为"),a("smalltex",[t._v("L_{MLM}=-\\Sigma_{t \\in T}log p_\\theta(w_t|C)")])],1),t._v(" "),a("li",[t._v("NSP (Next Sentence Prediction)：NSP任务用于预测两句话是否连续，假设"),a("smalltex",[t._v("y \\in {0, 1}")]),t._v("表示标签，"),a("smalltex",[t._v("p_\\theta(y|A,B)")]),t._v("是模型预测两句"),a("smalltex",[t._v("A")]),t._v("和"),a("smalltex",[t._v("B")]),t._v("是否连续的概率，那么NSP损失函数可以表示为："),a("smalltex",[t._v("L_{NSP}=-log p_\\theta(y|A,B)")]),t._v("$")],1)]),t._v(" "),a("h3",{attrs:{id:"gpt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gpt"}},[t._v("#")]),t._v(" GPT")]),t._v(" "),a("p",[t._v("GPT 使用 自回归语言模型 (Autoregressive Language Model) 的损失函数。其目标是根据前面的词预测下一个词。模型根据已知的词来最大化预测下一个词的出现概率。")]),t._v(" "),a("h2",{attrs:{id:"分布式训练"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式训练"}},[t._v("#")]),t._v(" 分布式训练")]),t._v(" "),a("ClientOnly",[a("leave")],1)],1)}),[],!1,null,null,null);a.default=v.exports}}]);